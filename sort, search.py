# 정렬(sort): 복수의 원소로 주어진 데이터를 정해진 기준에 따라 새로 늘어놓는 작업입니다.
# 이미 리스트(list)에 내장된 정렬 기능이 있기 때문입니다.

# 파이썬 내장 함수: sorted()
L = [3, 8, 2, 7, 6, 10, 9]
L2 = sorted(L)
print(L)
print(L2)

# 정렬의 결과를 역순으로
L3 = sorted(L, reverse=True)
print(L3)

# 리스트에 쓸 수 있는 메서드: .sort()
L.sort()
print(L)

# 정렬의 결과를 역순으로
L.sort(reverse=True)
print(L)

# 수치(number) 가 아닌 데이터형의 정렬: 이 경우에는 문자열을 사전에 등장하는 순서에 따라 정렬합니다.
# 문자열의 길이가 더 길다고 해서 더 큰 문자로 취급하는 것이 아님
# Python 문자열은 대문자가 소문자에 비해서 무조건 우선합니다.

# 문자열 길이 순서로 정렬하려면? -> 정렬에 이용하는 키(key)를 지정
L = ['abcd', 'xyz', 'spam', 'super']
sort = sorted(L, key=lambda x: len(x))
print(sort)

# 사전(dictionary)을 정렬하는 예:

# 레코드들을 이름 순서대로 정렬
L2 = [{'name': 'Son', 'score': 87}, {'name': 'Kane', 'score': 71}]
L2.sort(key=lambda x: x['name'])
print('record name:', L2)

# 레코드들을 점수 높은 순으로 정렬
L2.sort(key=lambda x: x['score'], reverse=True)
print('record score:', L2)

# 탐색(search): 복수의 원소로 이루어진 데이터에서 특정 원소를 찾아내는 작업입니다.

# 선형 탐색(linear search) 또는 순차 탐색(sequential search): 순차적으로 모든 요소들을 탐색하여 원하는 값을 찾아냅니다.
# 배열의 길이에 비례하는 시간이 걸리므로, 최악의 경우에는 배열에 있는 모든 원소를 다 검사해야 할 수 있습니다.
# 리스트의 길이에 비례하는 시간 소요 -> O(n) / 최악의 경우: 모든 원소를 다 비교해 보아야 함


def linear_search(L, x):
    i = 0
    while i < len(L) and L[i] != x:
        i += 1
    if i < len(L):
        return i
    else:
        return -1

# 이진 탐색(binary search): 탐색하려는 배열이 이미 정렬되어 있는 경우에만 적용할 수 있습니다.
# 배열의 가운데 원소와 찾으려 하는 값을 비교하면(크기 순으로 정렬되어 있다는 성질을 이용하면) 왼쪽에 있을지 오른쪽에 있을지를 알 수 있습니다.
# 그러면, 적어도 반대쪽에 없는 것은 확실하므로, 배열의 반을 탐색하지 않고 버릴 수 있습니다.
# 이 과정을 반복하면 원하는 값을 찾아낼 수 있습니다. 한번에 절반씩 배열을 잘려나간다면...몇 번이나 이 과정을 반복하게 될까..?
# 한번 비교가 일어날 때마다 리스트 반씩 줄임(divide & comquer) -> O(logN)


# 그래서 이진 탐색이 선형 탐색보다 빠른 방법이긴 함.
# 그러나, 뭔가를 찾으려 한다고 할 때, 항상 이진 탐색 방법을 적용하는 것이 답일까? 그럴러면 우선 배열을 정렬해야 한다던데, 크기 순으로 정렬하는 것은 금방 되나?
# 한 번만 탐색하고 말 거라면, 굳이 크기 순으로 늘어놓느라 시간을 소모하는 것보다 한번씩 다 뒤지는 것이 낫지 않나?!
print(0 + 15 // 2)
